#!/usr/bin/env node

import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const routesDir = path.join(__dirname, '../src/routes')
const outputFile = path.join(__dirname, '../src/server/client-routes.ts')

/**
 * Convert TanStack Router path to Express path
 * Examples:
 * - /n/$title -> /n/:title
 * - /api/$version/users -> /api/:version/users
 * - /blog/$slug/$id -> /blog/:slug/:id
 */
function convertToExpressPath(tanstackPath) {
  return tanstackPath.replace(/\$(\w+)/g, ':$1')
}

/**
 * Convert filesystem path to route path
 * Examples:
 * - index.tsx -> /
 * - about.tsx -> /about
 * - n/$title.tsx -> /n/$title
 * - api/$version/users.tsx -> /api/$version/users
 */
function filePathToRoutePath(filePath) {
  // Remove the routes directory prefix
  const relativePath = path.relative(routesDir, filePath)
  
  // Remove file extensions
  const withoutExt = relativePath.replace(/\.(tsx?|jsx?)$/, '')
  
  // Handle index files
  if (withoutExt === 'index' || withoutExt.endsWith('/index')) {
    return withoutExt.replace(/\/?index$/, '') || '/'
  }
  
  // Convert to route path
  let routePath = '/' + withoutExt.replace(/\\/g, '/')
  
  // Clean up double slashes
  routePath = routePath.replace(/\/+/g, '/')
  
  return routePath
}

/**
 * Recursively scan directory for route files
 */
function scanRoutes(dir) {
  const routes = []
  
  function scanDirectory(currentDir) {
    const entries = fs.readdirSync(currentDir, { withFileTypes: true })
    
    for (const entry of entries) {
      const fullPath = path.join(currentDir, entry.name)
      
      if (entry.isDirectory()) {
        scanDirectory(fullPath)
      } else if (entry.isFile() && /\.(tsx?|jsx?)$/.test(entry.name)) {
        // Skip special files
        if (entry.name.startsWith('__') || entry.name === '_layout.tsx') {
          continue
        }
        
        const routePath = filePathToRoutePath(fullPath)
        const expressPath = convertToExpressPath(routePath)
        
        routes.push({
          filePath: path.relative(routesDir, fullPath),
          routePath,
          expressPath,
          isDynamic: routePath.includes('$')
        })
      }
    }
  }
  
  scanDirectory(dir)
  return routes.sort((a, b) => a.routePath.localeCompare(b.routePath))
}

/**
 * Generate the client-routes.ts file
 */
function generateClientRoutes() {
  console.log('Scanning routes directory:', routesDir)
  
  if (!fs.existsSync(routesDir)) {
    console.error('Routes directory not found:', routesDir)
    process.exit(1)
  }
  
  const routes = scanRoutes(routesDir)
  console.log(`Found ${routes.length} routes:`)
  
  routes.forEach(route => {
    console.log(`  ${route.routePath} -> ${route.expressPath} ${route.isDynamic ? '(dynamic)' : '(static)'}`)
  })
  
  const staticRoutes = routes.filter(r => !r.isDynamic)
  const dynamicRoutes = routes.filter(r => r.isDynamic)
  
  const content = `// This file is auto-generated by scripts/generate-client-routes.js
// Do not edit manually - run 'pnpm run generate:routes' to update

import type { Express } from 'express'
import path from 'node:path'

// Static routes (exact matches)
export const STATIC_ROUTES = [
${staticRoutes.map(r => `  '${r.routePath}',`).join('\n')}
] as const

// Dynamic routes (with parameters)
export const DYNAMIC_ROUTES = [
${dynamicRoutes.map(r => `  { tanstack: '${r.routePath}', express: '${r.expressPath}' },`).join('\n')}
] as const

/**
 * Register all client routes with Express
 * This ensures the server can serve the React SPA for valid routes only
 */
export function registerClientRoutes(app: Express, distPath: string) {
  // Register static routes
  STATIC_ROUTES.forEach(route => {
    app.get(route, (_req, res) => {
      res.sendFile(path.join(distPath, 'index.html'))
    })
  })

  // Register dynamic routes
  DYNAMIC_ROUTES.forEach(({ express: expressPath }) => {
    app.get(expressPath, (_req, res) => {
      res.sendFile(path.join(distPath, 'index.html'))
    })
  })
}

/**
 * Check if a path matches any valid route pattern
 */
export function isValidClientRoute(pathname: string): boolean {
  // Check static routes
  if (STATIC_ROUTES.includes(pathname as any)) {
    return true
  }
  
  // Check dynamic routes by pattern matching
  for (const { tanstack } of DYNAMIC_ROUTES) {
    if (matchesDynamicRoute(pathname, tanstack)) {
      return true
    }
  }
  
  return false
}

/**
 * Check if a pathname matches a dynamic route pattern
 */
function matchesDynamicRoute(pathname: string, pattern: string): boolean {
  // Convert TanStack pattern to regex
  // /n/$title -> /n/([^/]+)
  const regexPattern = pattern
    .replace(/\$\\w+/g, '([^/]+)')
    .replace(/\\//g, '\\/')
  
  const regex = new RegExp('^' + regexPattern + '$')
  return regex.test(pathname)
}

// Export route information for debugging
export const ROUTE_INFO = {
  static: STATIC_ROUTES,
  dynamic: DYNAMIC_ROUTES,
  total: STATIC_ROUTES.length + DYNAMIC_ROUTES.length
}
`

  // Ensure the server directory exists
  const serverDir = path.dirname(outputFile)
  if (!fs.existsSync(serverDir)) {
    fs.mkdirSync(serverDir, { recursive: true })
  }

  // Write the file
  fs.writeFileSync(outputFile, content, 'utf8')
  console.log(`Generated client routes file: ${outputFile}`)
  console.log(`  Static routes: ${staticRoutes.length}`)
  console.log(`  Dynamic routes: ${dynamicRoutes.length}`)
}

// Run the generator
if (import.meta.url === `file://${process.argv[1]}`) {
  generateClientRoutes()
}